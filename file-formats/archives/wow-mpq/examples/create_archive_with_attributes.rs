//! Example of creating an MPQ archive with (attributes) file

use std::error::Error;
use wow_mpq::{
    ArchiveBuilder, FormatVersion, compression::flags as compression_flags, special_files::*,
};

fn main() -> Result<(), Box<dyn Error>> {
    println!("Creating MPQ archive with (attributes) file...");

    // Create some test files with known content
    let files = vec![
        (
            "readme.txt",
            b"This is a test archive with attributes".as_slice(),
        ),
        ("data/file1.dat", b"Some binary data here"),
        ("data/file2.dat", b"More binary data"),
    ];

    // Calculate attributes for ALL files (including special files)
    let mut file_attributes = Vec::new();

    // Add attributes for regular files
    for (_name, content) in &files {
        let mut attrs = FileAttributes::new();
        attrs.crc32 = Some(crc32(content));
        attrs.md5 = Some(md5(content));
        attrs.filetime = Some(current_filetime());
        attrs.is_patch = Some(false);
        file_attributes.push(attrs);
    }

    // Add dummy attributes for (attributes) file itself
    let mut attrs = FileAttributes::new();
    attrs.crc32 = Some(0); // Will be calculated later
    attrs.md5 = Some([0; 16]); // Will be calculated later
    attrs.filetime = Some(current_filetime());
    attrs.is_patch = Some(false);
    file_attributes.push(attrs);

    // Add attributes for (listfile)
    // The listfile will be auto-generated by the builder
    let listfile_content = files
        .iter()
        .map(|(name, _)| format!("{}\r\n", name))
        .collect::<String>()
        + "(attributes)\r\n(listfile)\r\n";
    let mut attrs = FileAttributes::new();
    attrs.crc32 = Some(crc32(listfile_content.as_bytes()));
    attrs.md5 = Some(md5(listfile_content.as_bytes()));
    attrs.filetime = Some(current_filetime());
    attrs.is_patch = Some(false);
    file_attributes.push(attrs);

    // Create the attributes structure
    let attributes = Attributes {
        version: Attributes::EXPECTED_VERSION,
        flags: AttributeFlags::new(AttributeFlags::ALL),
        file_attributes: file_attributes.clone(),
    };

    // Convert attributes to bytes
    let attributes_data = attributes.to_bytes()?;

    // Update the (attributes) entry with correct CRC32 and MD5
    file_attributes[files.len()].crc32 = Some(crc32(&attributes_data));
    file_attributes[files.len()].md5 = Some(md5(&attributes_data));

    // Recreate attributes with updated data
    let attributes = Attributes {
        version: Attributes::EXPECTED_VERSION,
        flags: AttributeFlags::new(AttributeFlags::ALL),
        file_attributes,
    };
    let attributes_data = attributes.to_bytes()?;

    // Create the archive
    let mut builder = ArchiveBuilder::new()
        .version(FormatVersion::V1)
        .default_compression(compression_flags::ZLIB);

    // Add regular files
    for (name, content) in &files {
        builder = builder.add_file_data(content.to_vec(), name);
    }

    // Add the (attributes) file
    builder = builder.add_file_data(attributes_data, "(attributes)");

    // Build the archive (this will also add the listfile)
    builder.build("archive_with_attributes.mpq")?;

    println!("Archive created successfully!");
    println!("Files in archive:");
    for (name, _) in &files {
        println!("  - {}", name);
    }
    println!("  - (attributes)");

    Ok(())
}

// Helper functions

fn crc32(data: &[u8]) -> u32 {
    let mut hasher = crc32fast::Hasher::new();
    hasher.update(data);
    hasher.finalize()
}

fn md5(data: &[u8]) -> [u8; 16] {
    use md5::{Digest, Md5};
    let mut hasher = Md5::new();
    hasher.update(data);
    hasher.finalize().into()
}

fn current_filetime() -> u64 {
    // Windows FILETIME: 100-nanosecond intervals since January 1, 1601
    // For simplicity, we'll use a fixed timestamp
    // In a real application, you'd convert from system time
    0x01D8F1A4_12345678
}
